program: TIMES
##
## Ends in an error in state: 0.
##
## program' -> . program [ # ]
##
## The known suffix of the stack is as follows:
##
##

Cool

program: NEWLINE TIMES
##
## Ends in an error in state: 1.
##
## list(NEWLINE) -> NEWLINE . list(NEWLINE) [ WHILE TRUE STRING RBRACE NOT MINUS MATCH LPAREN LBRACKET LBRACE INT IF ID FOR FLOAT FALSE EOF CHAR ]
##
## The known suffix of the stack is as follows:
## NEWLINE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: NEWLINE RBRACE
##
## Ends in an error in state: 4.
##
## program -> list(NEWLINE) . EOF [ # ]
## program -> list(NEWLINE) . statement_list_eof EOF [ # ]
##
## The known suffix of the stack is as follows:
## list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: WHILE WHILE
##
## Ends in an error in state: 5.
##
## while_loop -> WHILE . expression scope [ RBRACE NEWLINE EOF ]
##
## The known suffix of the stack is as follows:
## WHILE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: NOT WHILE
##
## Ends in an error in state: 8.
##
## uniOp -> NOT . expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## NOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MINUS WHILE
##
## Ends in an error in state: 9.
##
## uniOp -> MINUS . expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## MINUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LPAREN WHILE
##
## Ends in an error in state: 10.
##
## baseType -> LPAREN . option(expression) COMMA tuple [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> LPAREN . expression RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LBRACKET WHILE
##
## Ends in an error in state: 11.
##
## baseType -> LBRACKET . loption(separated_nonempty_list(COMMA,expression)) RBRACKET [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LBRACE TIMES
##
## Ends in an error in state: 12.
##
## scope -> LBRACE . list(NEWLINE) RBRACE [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA BACKSLASH AT ARROW AND ]
## scope -> LBRACE . list(NEWLINE) statement_list_scope RBRACE [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA BACKSLASH AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LBRACE NEWLINE EOF
##
## Ends in an error in state: 13.
##
## scope -> LBRACE list(NEWLINE) . RBRACE [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA BACKSLASH AT ARROW AND ]
## scope -> LBRACE list(NEWLINE) . statement_list_scope RBRACE [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA BACKSLASH AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## LBRACE list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH WHILE
##
## Ends in an error in state: 15.
##
## match_statement -> MATCH . expression LBRACE nonempty_list(match_branch) RBRACE [ RBRACE NEWLINE EOF ]
##
## The known suffix of the stack is as follows:
## MATCH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: IF ID WHILE
##
## Ends in an error in state: 17.
##
## expression -> ID . [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> ID . LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID LPAREN WHILE
##
## Ends in an error in state: 18.
##
## expression -> ID LPAREN . loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## ID LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID LPAREN CHAR RBRACKET
##
## Ends in an error in state: 25.
##
## expression -> ID LPAREN loption(separated_nonempty_list(COMMA,expression)) . RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## ID LPAREN loption(separated_nonempty_list(COMMA,expression))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 27, spurious reduction of production separated_nonempty_list(COMMA,expression) -> expression
## In state 23, spurious reduction of production loption(separated_nonempty_list(COMMA,expression)) -> separated_nonempty_list(COMMA,expression)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LBRACKET CHAR RBRACE
##
## Ends in an error in state: 27.
##
## binOp -> expression . PLUS expression [ TIMES RPAREN RBRACKET PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . MINUS expression [ TIMES RPAREN RBRACKET PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . TIMES expression [ TIMES RPAREN RBRACKET PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . DIV expression [ TIMES RPAREN RBRACKET PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . MOD expression [ TIMES RPAREN RBRACKET PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . EXP expression [ TIMES RPAREN RBRACKET PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . EQ expression [ TIMES RPAREN RBRACKET PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . NEQ expression [ TIMES RPAREN RBRACKET PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . LT expression [ TIMES RPAREN RBRACKET PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . LEQ expression [ TIMES RPAREN RBRACKET PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . GT expression [ TIMES RPAREN RBRACKET PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . GEQ expression [ TIMES RPAREN RBRACKET PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . AND expression [ TIMES RPAREN RBRACKET PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . OR expression [ TIMES RPAREN RBRACKET PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## expression -> expression . AT ID [ TIMES RPAREN RBRACKET PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## expression -> expression . DOT ID [ TIMES RPAREN RBRACKET PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RPAREN RBRACKET PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## separated_nonempty_list(COMMA,expression) -> expression . [ RPAREN RBRACKET ]
## separated_nonempty_list(COMMA,expression) -> expression . COMMA separated_nonempty_list(COMMA,expression) [ RPAREN RBRACKET ]
##
## The known suffix of the stack is as follows:
## expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID TIMES WHILE
##
## Ends in an error in state: 28.
##
## binOp -> expression TIMES . expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression TIMES
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID TIMES CHAR WHILE
##
## Ends in an error in state: 29.
##
## binOp -> expression . PLUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MINUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . TIMES expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression TIMES expression . [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . DIV expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MOD expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EXP expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . NEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . AND expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . OR expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . AT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression TIMES expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID EXP WHILE
##
## Ends in an error in state: 30.
##
## binOp -> expression EXP . expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression EXP
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID EXP CHAR WHILE
##
## Ends in an error in state: 31.
##
## binOp -> expression . PLUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MINUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . TIMES expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . DIV expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MOD expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EXP expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression EXP expression . [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . NEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . AND expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . OR expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . AT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression EXP expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID DOT WHILE
##
## Ends in an error in state: 32.
##
## expression -> expression DOT . ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression DOT . ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID DOT ID WHILE
##
## Ends in an error in state: 33.
##
## expression -> expression DOT ID . [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression DOT ID . LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression DOT ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID DOT ID LPAREN WHILE
##
## Ends in an error in state: 34.
##
## expression -> expression DOT ID LPAREN . loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression DOT ID LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID DOT ID LPAREN CHAR RBRACKET
##
## Ends in an error in state: 35.
##
## expression -> expression DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) . RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 27, spurious reduction of production separated_nonempty_list(COMMA,expression) -> expression
## In state 23, spurious reduction of production loption(separated_nonempty_list(COMMA,expression)) -> separated_nonempty_list(COMMA,expression)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID PLUS WHILE
##
## Ends in an error in state: 39.
##
## binOp -> expression PLUS . expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression PLUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID PLUS CHAR WHILE
##
## Ends in an error in state: 40.
##
## binOp -> expression . PLUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression PLUS expression . [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MINUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . TIMES expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . DIV expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MOD expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EXP expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . NEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . AND expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . OR expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . AT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression PLUS expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID MOD WHILE
##
## Ends in an error in state: 41.
##
## binOp -> expression MOD . expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression MOD
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID MOD CHAR WHILE
##
## Ends in an error in state: 42.
##
## binOp -> expression . PLUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MINUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . TIMES expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . DIV expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MOD expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression MOD expression . [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EXP expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . NEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . AND expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . OR expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . AT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression MOD expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID DIV WHILE
##
## Ends in an error in state: 43.
##
## binOp -> expression DIV . expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression DIV
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID DIV CHAR WHILE
##
## Ends in an error in state: 44.
##
## binOp -> expression . PLUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MINUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . TIMES expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . DIV expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression DIV expression . [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MOD expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EXP expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . NEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . AND expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . OR expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . AT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression DIV expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID OR WHILE
##
## Ends in an error in state: 45.
##
## binOp -> expression OR . expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression OR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID OR CHAR WHILE
##
## Ends in an error in state: 46.
##
## binOp -> expression . PLUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MINUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . TIMES expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . DIV expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MOD expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EXP expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . NEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . AND expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . OR expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression OR expression . [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . AT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression OR expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID NEQ WHILE
##
## Ends in an error in state: 47.
##
## binOp -> expression NEQ . expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression NEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID NEQ CHAR WHILE
##
## Ends in an error in state: 48.
##
## binOp -> expression . PLUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MINUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . TIMES expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . DIV expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MOD expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EXP expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . NEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression NEQ expression . [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . AND expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . OR expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . AT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression NEQ expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID MINUS WHILE
##
## Ends in an error in state: 49.
##
## binOp -> expression MINUS . expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression MINUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID MINUS CHAR WHILE
##
## Ends in an error in state: 50.
##
## binOp -> expression . PLUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MINUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression MINUS expression . [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . TIMES expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . DIV expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MOD expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EXP expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . NEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . AND expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . OR expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . AT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression MINUS expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID LT WHILE
##
## Ends in an error in state: 51.
##
## binOp -> expression LT . expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression LT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID LT CHAR WHILE
##
## Ends in an error in state: 52.
##
## binOp -> expression . PLUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MINUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . TIMES expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . DIV expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MOD expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EXP expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . NEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression LT expression . [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . AND expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . OR expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . AT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression LT expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID LEQ WHILE
##
## Ends in an error in state: 53.
##
## binOp -> expression LEQ . expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression LEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID LEQ CHAR WHILE
##
## Ends in an error in state: 54.
##
## binOp -> expression . PLUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MINUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . TIMES expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . DIV expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MOD expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EXP expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . NEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression LEQ expression . [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . AND expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . OR expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . AT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression LEQ expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID GT WHILE
##
## Ends in an error in state: 55.
##
## binOp -> expression GT . expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression GT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID GT CHAR WHILE
##
## Ends in an error in state: 56.
##
## binOp -> expression . PLUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MINUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . TIMES expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . DIV expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MOD expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EXP expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . NEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression GT expression . [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . AND expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . OR expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . AT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression GT expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID GEQ WHILE
##
## Ends in an error in state: 57.
##
## binOp -> expression GEQ . expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression GEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID GEQ CHAR WHILE
##
## Ends in an error in state: 58.
##
## binOp -> expression . PLUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MINUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . TIMES expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . DIV expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MOD expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EXP expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . NEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression GEQ expression . [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . AND expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . OR expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . AT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression GEQ expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID EQ WHILE
##
## Ends in an error in state: 59.
##
## binOp -> expression EQ . expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID EQ CHAR WHILE
##
## Ends in an error in state: 60.
##
## binOp -> expression . PLUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MINUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . TIMES expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . DIV expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MOD expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EXP expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression EQ expression . [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . NEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . AND expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . OR expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . AT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression EQ expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID AND WHILE
##
## Ends in an error in state: 61.
##
## binOp -> expression AND . expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression AND
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID AND CHAR WHILE
##
## Ends in an error in state: 62.
##
## binOp -> expression . PLUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MINUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . TIMES expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . DIV expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MOD expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EXP expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . NEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . AND expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression AND expression . [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . OR expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . AT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression AND expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LBRACKET CHAR COMMA WHILE
##
## Ends in an error in state: 63.
##
## separated_nonempty_list(COMMA,expression) -> expression COMMA . separated_nonempty_list(COMMA,expression) [ RPAREN RBRACKET ]
##
## The known suffix of the stack is as follows:
## expression COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID AT WHILE
##
## Ends in an error in state: 65.
##
## expression -> expression AT . ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression AT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH CHAR RPAREN
##
## Ends in an error in state: 67.
##
## binOp -> expression . PLUS expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . MINUS expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . TIMES expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . DIV expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . MOD expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . EXP expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . EQ expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . NEQ expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . LT expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . LEQ expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . GT expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . GEQ expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . AND expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . OR expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## expression -> expression . AT ID [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## expression -> expression . DOT ID [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## match_statement -> MATCH expression . LBRACE nonempty_list(match_branch) RBRACE [ RBRACE NEWLINE EOF ]
##
## The known suffix of the stack is as follows:
## MATCH expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH CHAR LBRACE WHILE
##
## Ends in an error in state: 68.
##
## match_statement -> MATCH expression LBRACE . nonempty_list(match_branch) RBRACE [ RBRACE NEWLINE EOF ]
##
## The known suffix of the stack is as follows:
## MATCH expression LBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH CHAR LBRACE BACKSLASH WHILE
##
## Ends in an error in state: 69.
##
## match_branch -> BACKSLASH . expression ARROW scope [ RBRACE BACKSLASH ]
##
## The known suffix of the stack is as follows:
## BACKSLASH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH CHAR LBRACE BACKSLASH CHAR RPAREN
##
## Ends in an error in state: 70.
##
## binOp -> expression . PLUS expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV AT ARROW AND ]
## binOp -> expression . MINUS expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV AT ARROW AND ]
## binOp -> expression . TIMES expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV AT ARROW AND ]
## binOp -> expression . DIV expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV AT ARROW AND ]
## binOp -> expression . MOD expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV AT ARROW AND ]
## binOp -> expression . EXP expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV AT ARROW AND ]
## binOp -> expression . EQ expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV AT ARROW AND ]
## binOp -> expression . NEQ expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV AT ARROW AND ]
## binOp -> expression . LT expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV AT ARROW AND ]
## binOp -> expression . LEQ expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV AT ARROW AND ]
## binOp -> expression . GT expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV AT ARROW AND ]
## binOp -> expression . GEQ expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV AT ARROW AND ]
## binOp -> expression . AND expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV AT ARROW AND ]
## binOp -> expression . OR expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV AT ARROW AND ]
## expression -> expression . AT ID [ TIMES PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV AT ARROW AND ]
## expression -> expression . DOT ID [ TIMES PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV AT ARROW AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV AT ARROW AND ]
## match_branch -> BACKSLASH expression . ARROW scope [ RBRACE BACKSLASH ]
##
## The known suffix of the stack is as follows:
## BACKSLASH expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH CHAR LBRACE BACKSLASH CHAR ARROW WHILE
##
## Ends in an error in state: 71.
##
## match_branch -> BACKSLASH expression ARROW . scope [ RBRACE BACKSLASH ]
##
## The known suffix of the stack is as follows:
## BACKSLASH expression ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH CHAR LBRACE BACKSLASH CHAR ARROW LBRACE RBRACE WHILE
##
## Ends in an error in state: 75.
##
## nonempty_list(match_branch) -> match_branch . [ RBRACE ]
## nonempty_list(match_branch) -> match_branch . nonempty_list(match_branch) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## match_branch
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: IF WHILE
##
## Ends in an error in state: 77.
##
## if_statement -> IF . expression scope [ RBRACE NEWLINE EOF ]
##
## The known suffix of the stack is as follows:
## IF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: IF CHAR RPAREN
##
## Ends in an error in state: 78.
##
## binOp -> expression . PLUS expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . MINUS expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . TIMES expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . DIV expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . MOD expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . EXP expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . EQ expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . NEQ expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . LT expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . LEQ expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . GT expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . GEQ expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . AND expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . OR expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## expression -> expression . AT ID [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## expression -> expression . DOT ID [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## if_statement -> IF expression . scope [ RBRACE NEWLINE EOF ]
##
## The known suffix of the stack is as follows:
## IF expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID WHILE
##
## Ends in an error in state: 80.
##
## expression -> ID . [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## expression -> ID . LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## function_definition -> ID . BACKSLASH list(ID) ARROW scope [ RBRACE NEWLINE EOF ]
## variable_assignment -> ID . EQUALS expression [ RBRACE NEWLINE EOF ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID EQUALS WHILE
##
## Ends in an error in state: 81.
##
## variable_assignment -> ID EQUALS . expression [ RBRACE NEWLINE EOF ]
##
## The known suffix of the stack is as follows:
## ID EQUALS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID EQUALS CHAR RPAREN
##
## Ends in an error in state: 82.
##
## binOp -> expression . PLUS expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . MINUS expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . TIMES expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . DIV expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . MOD expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . EXP expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . EQ expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . NEQ expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . LT expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . LEQ expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . GT expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . GEQ expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . AND expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . OR expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## expression -> expression . AT ID [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## expression -> expression . DOT ID [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## variable_assignment -> ID EQUALS expression . [ RBRACE NEWLINE EOF ]
##
## The known suffix of the stack is as follows:
## ID EQUALS expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID BACKSLASH WHILE
##
## Ends in an error in state: 83.
##
## function_definition -> ID BACKSLASH . list(ID) ARROW scope [ RBRACE NEWLINE EOF ]
##
## The known suffix of the stack is as follows:
## ID BACKSLASH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID BACKSLASH ID WHILE
##
## Ends in an error in state: 84.
##
## list(ID) -> ID . list(ID) [ ARROW ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID BACKSLASH ARROW WHILE
##
## Ends in an error in state: 87.
##
## function_definition -> ID BACKSLASH list(ID) ARROW . scope [ RBRACE NEWLINE EOF ]
##
## The known suffix of the stack is as follows:
## ID BACKSLASH list(ID) ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FOR WHILE
##
## Ends in an error in state: 89.
##
## for_loop -> FOR . ID IN expression scope [ RBRACE NEWLINE EOF ]
##
## The known suffix of the stack is as follows:
## FOR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FOR ID WHILE
##
## Ends in an error in state: 90.
##
## for_loop -> FOR ID . IN expression scope [ RBRACE NEWLINE EOF ]
##
## The known suffix of the stack is as follows:
## FOR ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FOR ID IN WHILE
##
## Ends in an error in state: 91.
##
## for_loop -> FOR ID IN . expression scope [ RBRACE NEWLINE EOF ]
##
## The known suffix of the stack is as follows:
## FOR ID IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FOR ID IN CHAR RPAREN
##
## Ends in an error in state: 92.
##
## binOp -> expression . PLUS expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . MINUS expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . TIMES expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . DIV expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . MOD expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . EXP expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . EQ expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . NEQ expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . LT expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . LEQ expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . GT expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . GEQ expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . AND expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . OR expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## expression -> expression . AT ID [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## expression -> expression . DOT ID [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## for_loop -> FOR ID IN expression . scope [ RBRACE NEWLINE EOF ]
##
## The known suffix of the stack is as follows:
## FOR ID IN expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LBRACE ID NEWLINE EOF
##
## Ends in an error in state: 96.
##
## scope -> LBRACE list(NEWLINE) statement_list_scope . RBRACE [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA BACKSLASH AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## LBRACE list(NEWLINE) statement_list_scope
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 99, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
## In state 108, spurious reduction of production statement_list_scope -> statement list(NEWLINE)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LBRACE ID EOF
##
## Ends in an error in state: 98.
##
## statement_list_scope -> statement . list(NEWLINE) [ RBRACE ]
## statement_list_scope -> statement . nonempty_list(NEWLINE) statement_list_scope [ RBRACE ]
##
## The known suffix of the stack is as follows:
## statement
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production expression -> ID
## In state 107, spurious reduction of production statement -> expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID NEWLINE TIMES
##
## Ends in an error in state: 99.
##
## list(NEWLINE) -> NEWLINE . list(NEWLINE) [ RBRACE EOF ]
## nonempty_list(NEWLINE) -> NEWLINE . [ WHILE TRUE STRING NOT MINUS MATCH LPAREN LBRACKET LBRACE INT IF ID FOR FLOAT FALSE CHAR ]
## nonempty_list(NEWLINE) -> NEWLINE . nonempty_list(NEWLINE) [ WHILE TRUE STRING NOT MINUS MATCH LPAREN LBRACKET LBRACE INT IF ID FOR FLOAT FALSE CHAR ]
##
## The known suffix of the stack is as follows:
## NEWLINE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: CHAR RPAREN
##
## Ends in an error in state: 107.
##
## binOp -> expression . PLUS expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . MINUS expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . TIMES expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . DIV expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . MOD expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . EXP expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . EQ expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . NEQ expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . LT expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . LEQ expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . GT expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . GEQ expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . AND expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## binOp -> expression . OR expression [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## expression -> expression . AT ID [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## expression -> expression . DOT ID [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ GT GEQ EXP EQ EOF DOT DIV AT AND ]
## statement -> expression . [ RBRACE NEWLINE EOF ]
##
## The known suffix of the stack is as follows:
## expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LBRACKET CHAR RPAREN
##
## Ends in an error in state: 109.
##
## baseType -> LBRACKET loption(separated_nonempty_list(COMMA,expression)) . RBRACKET [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## LBRACKET loption(separated_nonempty_list(COMMA,expression))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 27, spurious reduction of production separated_nonempty_list(COMMA,expression) -> expression
## In state 23, spurious reduction of production loption(separated_nonempty_list(COMMA,expression)) -> separated_nonempty_list(COMMA,expression)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LPAREN COMMA WHILE
##
## Ends in an error in state: 112.
##
## baseType -> LPAREN option(expression) COMMA . tuple [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## LPAREN option(expression) COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LPAREN COMMA CHAR RBRACKET
##
## Ends in an error in state: 115.
##
## binOp -> expression . PLUS expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . MINUS expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . TIMES expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . DIV expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . MOD expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . EXP expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . EQ expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . NEQ expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . LT expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . LEQ expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . GT expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . GEQ expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . AND expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . OR expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## expression -> expression . AT ID [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## expression -> expression . DOT ID [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## tuple -> expression . RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## tuple -> expression . COMMA tuple [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LPAREN COMMA CHAR COMMA WHILE
##
## Ends in an error in state: 117.
##
## tuple -> expression COMMA . tuple [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## expression COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LPAREN CHAR RBRACKET
##
## Ends in an error in state: 119.
##
## binOp -> expression . PLUS expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . MINUS expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . TIMES expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . DIV expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . MOD expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . EXP expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . EQ expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . NEQ expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . LT expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . LEQ expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . GT expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . GEQ expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . AND expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## binOp -> expression . OR expression [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## expression -> expression . AT ID [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## expression -> LPAREN expression . RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EXP EQ DOT DIV COMMA AT AND ]
## option(expression) -> expression . [ COMMA ]
##
## The known suffix of the stack is as follows:
## LPAREN expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MINUS CHAR WHILE
##
## Ends in an error in state: 121.
##
## binOp -> expression . PLUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MINUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . TIMES expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . DIV expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MOD expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EXP expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . NEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . AND expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . OR expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . AT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## uniOp -> MINUS expression . [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## MINUS expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: NOT CHAR WHILE
##
## Ends in an error in state: 122.
##
## binOp -> expression . PLUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MINUS expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . TIMES expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . DIV expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . MOD expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EXP expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . EQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . NEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . LEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GT expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . GEQ expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . AND expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## binOp -> expression . OR expression [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . AT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
## uniOp -> NOT expression . [ TIMES RPAREN RBRACKET RBRACE PLUS OR NEWLINE NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ EOF DOT DIV COMMA AT ARROW AND ]
##
## The known suffix of the stack is as follows:
## NOT expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: WHILE CHAR RPAREN
##
## Ends in an error in state: 123.
##
## binOp -> expression . PLUS expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . MINUS expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . TIMES expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . DIV expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . MOD expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . EXP expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . EQ expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . NEQ expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . LT expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . LEQ expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . GT expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . GEQ expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . AND expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## binOp -> expression . OR expression [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## expression -> expression . AT ID [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## expression -> expression . DOT ID [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## expression -> expression . DOT ID LPAREN loption(separated_nonempty_list(COMMA,expression)) RPAREN [ TIMES PLUS OR NEQ MOD MINUS LT LEQ LBRACE GT GEQ EXP EQ DOT DIV AT AND ]
## while_loop -> WHILE expression . scope [ RBRACE NEWLINE EOF ]
##
## The known suffix of the stack is as follows:
## WHILE expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID NEWLINE RBRACE
##
## Ends in an error in state: 126.
##
## program -> list(NEWLINE) statement_list_eof . EOF [ # ]
##
## The known suffix of the stack is as follows:
## list(NEWLINE) statement_list_eof
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 99, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
## In state 131, spurious reduction of production statement_list_eof -> statement list(NEWLINE)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID RBRACE
##
## Ends in an error in state: 128.
##
## statement_list_eof -> statement . list(NEWLINE) [ EOF ]
## statement_list_eof -> statement . nonempty_list(NEWLINE) statement_list_eof [ EOF ]
##
## The known suffix of the stack is as follows:
## statement
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production expression -> ID
## In state 107, spurious reduction of production statement -> expression
##

<YOUR SYNTAX ERROR MESSAGE HERE>
